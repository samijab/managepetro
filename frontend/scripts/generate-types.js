#!/usr/bin/env node

/**
 * TypeScript Type Generator from OpenAPI Schema
 *
 * This script fetches the OpenAPI schema from the FastAPI backend
 * and generates TypeScript types for the frontend.
 *
 * Usage:
 *   node scripts/generate-types.js
 *
 * Or add to package.json:
 *   "scripts": {
 *     "generate-types": "node scripts/generate-types.js"
 *   }
 */

import { writeFileSync, mkdirSync } from "fs";
import { join, dirname as pathDirname } from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = pathDirname(__filename);

// Configuration - can be overridden via environment variables
const BACKEND_URL =
  process.env.BACKEND_URL ||
  process.env.VITE_API_BASE_URL ||
  "http://localhost:8000";
const OUTPUT_FILE = join(__dirname, "../src/types/api.ts");

/**
 * Fetch OpenAPI schema from backend
 */
async function fetchOpenAPISchema() {
  try {
    const response = await fetch(`${BACKEND_URL}/openapi.json`);
    if (!response.ok) {
      throw new Error(`Failed to fetch OpenAPI schema: ${response.statusText}`);
    }
    return await response.json();
  } catch (error) {
    console.error("Error fetching OpenAPI schema:", error.message);
    console.error("Make sure your backend is running at:", BACKEND_URL);
    throw error;
  }
}

/**
 * Convert OpenAPI type to TypeScript type
 */
function convertType(schema, definitions = {}) {
  if (!schema) return "any";

  // Handle references
  if (schema.$ref) {
    const refName = schema.$ref.split("/").pop();
    return refName;
  }

  // Handle arrays
  if (schema.type === "array") {
    const itemType = convertType(schema.items, definitions);
    return `${itemType}[]`;
  }

  // Handle objects
  if (schema.type === "object") {
    if (schema.properties) {
      const props = Object.entries(schema.properties).map(([key, value]) => {
        const isRequired = schema.required?.includes(key);
        const optional = isRequired ? "" : "?";
        return `  ${key}${optional}: ${convertType(value, definitions)}`;
      });
      return `{\n${props.join(";\n")};\n}`;
    }
    return "Record<string, any>";
  }

  // Handle primitives
  const typeMap = {
    string: "string",
    number: "number",
    integer: "number",
    boolean: "boolean",
    null: "null",
  };

  return typeMap[schema.type] || "any";
}

/**
 * Generate TypeScript interfaces from OpenAPI components
 */
function generateTypes(openApiSchema) {
  const components = openApiSchema.components?.schemas || {};

  let output = `/**
 * Auto-generated TypeScript types from OpenAPI schema
 * 
 * DO NOT EDIT THIS FILE MANUALLY
 * Generated on: ${new Date().toISOString()}
 * 
 * To regenerate, run: npm run generate-types
 */

`;

  // Generate interface for each component schema
  for (const [name, schema] of Object.entries(components)) {
    output += `export interface ${name} ${convertType(schema, components)}\n\n`;
  }

  // Generate API endpoint types
  output += generateEndpointTypes(openApiSchema);

  return output;
}

/**
 * Generate types for API endpoints
 */
function generateEndpointTypes(openApiSchema) {
  const paths = openApiSchema.paths || {};
  let output = "// API Endpoint Request/Response Types\n\n";

  for (const [path, methods] of Object.entries(paths)) {
    for (const [method, operation] of Object.entries(methods)) {
      if (typeof operation !== "object") continue;

      const operationId =
        operation.operationId || `${method}_${path.replace(/\//g, "_")}`;

      // Request body type
      if (operation.requestBody?.content?.["application/json"]?.schema) {
        const schema = operation.requestBody.content["application/json"].schema;
        const typeName = `${operationId}Request`;
        output += `export type ${typeName} = ${convertType(schema)};\n\n`;
      }

      // Response type
      if (operation.responses?.["200"]?.content?.["application/json"]?.schema) {
        const schema =
          operation.responses["200"].content["application/json"].schema;
        const typeName = `${operationId}Response`;
        output += `export type ${typeName} = ${convertType(schema)};\n\n`;
      }
    }
  }

  return output;
}

/**
 * Main execution
 */
async function main() {
  try {
    console.log("üîÑ Fetching OpenAPI schema from backend...");
    const openApiSchema = await fetchOpenAPISchema();

    console.log("‚ú® Generating TypeScript types...");
    const types = generateTypes(openApiSchema);

    // Ensure types directory exists
    const typesDir = pathDirname(OUTPUT_FILE);
    try {
      mkdirSync(typesDir, { recursive: true });
    } catch {
      // Directory might already exist, ignore error
    }

    console.log("üìù Writing types to:", OUTPUT_FILE);
    writeFileSync(OUTPUT_FILE, types, "utf-8");

    console.log("‚úÖ Type generation complete!");
    console.log("\nGenerated types are available at: src/types/api.ts");
  } catch (error) {
    console.error("‚ùå Type generation failed:", error.message);
    throw error;
  }
}

main().catch(console.error);
